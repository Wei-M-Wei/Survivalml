% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/survival_estimate.R
\name{cv.survival_sparsegl}
\alias{cv.survival_sparsegl}
\title{Cross-validation for a `survival_sparsegl` object.}
\usage{
cv.survival_sparsegl(
  x,
  y,
  group = NULL,
  family = c("binomial"),
  lambda = NULL,
  pred.loss = c("default", "mse", "deviance", "mae", "misclass", "censor", "AUC_censor"),
  nfolds = 10,
  foldid = NULL,
  weights = NULL,
  offset = NULL,
  weight,
  intercept_zero,
  AUC = FALSE,
  maxit = 20000,
  ...
)
}
\arguments{
\item{x}{Double. A matrix of predictors, of dimension
\eqn{n \times p}{n * p}; each row
is a vector of measurements and each column is a feature. Objects of class
[`Matrix::sparseMatrix`] are supported.}

\item{y}{Double/Integer/Factor. Either a factor with two levels or
a vector of integers taking 2 unique values. For a factor, the last level
in alphabetical order is the target class.}

\item{group}{Integer. A vector of consecutive integers describing the
grouping of the coefficients (see example below).}

\item{lambda}{A user supplied `lambda` sequence. The default, `NULL`
results in an automatic computation based on `nlambda`, the smallest value
of `lambda` that would give the null model (all coefficient estimates equal
to zero), and `lambda.factor`. Supplying a value of `lambda` overrides
this behaviour. It is likely better to supply a
decreasing sequence of `lambda` values than a single (small) value. If
supplied, the user-defined `lambda` sequence is automatically sorted in
decreasing order.}

\item{pred.loss}{Loss to use for cross-validation error. Valid options are:
* `"default"` the same as deviance (mse for regression and deviance otherwise)
* `"mse"` mean square error
* `"deviance"` the default (mse for Gaussian regression, and negative
  log-likelihood otherwise)
* `"mae"` mean absolute error, can apply to any family
* `"misclass"` for classification only, misclassification error.}

\item{nfolds}{Number of folds - default is 10. Although `nfolds` can be
as large as the sample size (leave-one-out CV), it is not recommended for
large datasets. Smallest value allowable is `nfolds = 3`.}

\item{foldid}{An optional vector of values between 1 and `nfolds`
identifying which fold each observation is in. If supplied, `nfolds` can
be missing.}

\item{offset}{Double vector. Optional offset (constant predictor without a
corresponding coefficient). These can only be used with a
[stats::family()] object.}

\item{weight}{Double vector. It represents the weighting of censored individuals.}

\item{maxit}{Maximum number of outer-loop iterations allowed at fixed lambda
value. Default is `3e8`. If models do not converge, consider increasing
`maxit`.}

\item{...}{Additional arguments to [survival_sparsegl()].}
}
\value{
An object of class [cv.survival_sparsegl()] is returned, which is a
  list with the components describing the cross-validation error.
  \item{lambda}{The values of \code{lambda} used in the fits.}
  \item{cvm}{The mean cross-validated error - a vector of
    length \code{length(lambda)}.}
  \item{cvsd}{Estimate of standard error of \code{cvm}.}
  \item{cvupper}{Upper curve = \code{cvm + cvsd}.}
  \item{cvlower}{Lower curve = \code{cvm - cvsd}.}
  \item{name}{A text string indicating type of measure (for plotting
    purposes).}
  \item{nnzero}{The number of non-zero coefficients for each \code{lambda}}
  \item{active_grps}{The number of active groups for each \code{lambda}}
  \item{survival_sparsegl.fit}{A fitted [survival_sparsegl()] object for the full data.}
  \item{lambda.min}{The optimal value of \code{lambda} that gives
    minimum cross validation error \code{cvm}.}
  \item{lambda.1se}{The largest value of \code{lambda} such that error
    is within 1 standard error of the minimum.}
  \item{call}{The function call.}
}
\description{
Performs k-fold cross-validation for [survival_sparsegl()].
This function is largely similar [glmnet::cv.glmnet()].
}
\details{
The function runs [survival_sparsegl()] `nfolds + 1` times; the first to
get the `lambda` sequence, and then the remainder to compute the fit
with each of the folds omitted. The average error and standard error
over the folds are computed.
}
\examples{
n <- 100
p <- 20
X <- matrix(rnorm(n * p), nrow = n)
eps <- rnorm(n)
beta_star <- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), rep(0, (p - 15)))
y <- X \%*\% beta_star + eps
groups <- rep(1:(p / 5), each = 5)
cv_fit <- cv.survival_sparsegl(X, y, groups)

}
\seealso{
[survival_sparsegl()], as well as [`plot()`][plot.cv.survival_sparsegl()],
  [`predict()`][predict.cv.survival_sparsegl()], and [`coef()`][coef.cv.survival_sparsegl()]
  methods for `"cv.survival_sparsegl"` objects.
}
