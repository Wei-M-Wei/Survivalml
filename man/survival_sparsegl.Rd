% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/survival_estimate.R
\name{survival_sparsegl}
\alias{survival_sparsegl}
\title{High-dimensional censored MIDAS logistic regression for corporate survival forecasting}
\usage{
survival_sparsegl(
  x,
  y,
  weight,
  intercept_zero,
  group = NULL,
  nlambda = 100,
  lambda.factor = ifelse(nobs < nvars, 0.01, 1e-04),
  lambda = NULL,
  pf_group = sqrt(bs),
  pf_sparse = rep(1, nvars),
  intercept = TRUE,
  asparse = 0.05,
  standardize = TRUE,
  lower_bnd = -Inf,
  upper_bnd = Inf,
  weights = NULL,
  offset = NULL,
  warm = NULL,
  trace_it = 0,
  dfmax = as.integer(max(group)) + 1L,
  pmax = min(dfmax * 1.2, as.integer(max(group))),
  eps = 1e-08,
  maxit = 1e+05
)
}
\arguments{
\item{x}{Double. A matrix of predictors, of dimension
\eqn{n \times p}{n * p}; each row
is a vector of measurements and each column is a feature. Objects of class
[`Matrix::sparseMatrix`] are supported.}

\item{y}{Double/Integer/Factor. Either a factor with two levels or
a vector of integers taking 2 unique values. For a factor, the last level
in alphabetical order is the target class.}

\item{weight}{Double vector. It represents the weighting vector of censored individuals.}

\item{group}{Integer. A vector of consecutive integers describing the
grouping of the coefficients (see example below).}

\item{nlambda}{The number of \code{lambda} values - default is 100.}

\item{lambda.factor}{A multiplicative factor for the minimal lambda in the
`lambda` sequence, where `min(lambda) = lambda.factor * max(lambda)`.
`max(lambda)` is the smallest value of `lambda` for which all coefficients
are zero. The default depends on the relationship between \eqn{n}
(the number of rows in the matrix of predictors) and \eqn{p}
(the number of predictors). If \eqn{n \geq p}, the
default is `0.0001`.  If \eqn{n < p}, the default is `0.01`.
A very small value of `lambda.factor` will lead to a
saturated fit. This argument has no effect if there is user-defined
`lambda` sequence.}

\item{lambda}{A user supplied `lambda` sequence. The default, `NULL`
results in an automatic computation based on `nlambda`, the smallest value
of `lambda` that would give the null model (all coefficient estimates equal
to zero), and `lambda.factor`. Supplying a value of `lambda` overrides
this behaviour. It is likely better to supply a
decreasing sequence of `lambda` values than a single (small) value. If
supplied, the user-defined `lambda` sequence is automatically sorted in
decreasing order.}

\item{pf_group}{Penalty factor on the groups, a vector of the same
length as the total number of groups. Separate penalty weights can be applied
to each group of \eqn{\beta}{beta's}s to allow differential shrinkage.
Can be 0 for some
groups, which implies no shrinkage, and results in that group always being
included in the model (depending on `pf_sparse`). Default value for each
entry is the square-root of the corresponding size of each group.
Because this default is typical, these penalties are not rescaled.}

\item{pf_sparse}{Penalty factor on l1-norm, a vector the same length as the
total number of columns in `x`. Each value corresponds to one predictor
Can be 0 for some predictors, which
implies that predictor will be receive only the group penalty.
Note that these are internally rescaled so that the sum is the same as
the number of predictors.}

\item{intercept}{Whether to include intercept in the model. Default is TRUE.}

\item{asparse}{The relative weight to put on the \eqn{\ell_1}-norm in
sparse group lasso. Default is `0.05` (resulting in `0.95` on the
\eqn{\ell_2}-norm).}

\item{standardize}{Logical flag for variable standardization (scaling) prior
to fitting the model. Default is TRUE.}

\item{lower_bnd}{Lower bound for coefficient values, a vector in length of 1
or of length the number of groups. Must be non-positive numbers only.
Default value for each entry is `-Inf`.}

\item{upper_bnd}{Upper for coefficient values, a vector in length of 1
or of length the number of groups. Must be non-negative numbers only.
Default value for each entry is `Inf`.}

\item{offset}{Double vector. Optional offset (constant predictor without a
corresponding coefficient). These can only be used with a
[stats::family()] object.}

\item{trace_it}{Scalar integer. Larger values print more output during
the irls loop. Typical values are `0` (no printing), `1` (some printing
and a progress bar), and `2` (more detailed printing).
These can only be used with a [stats::family()] object.}

\item{dfmax}{Limit the maximum number of groups in the model. Default is
no limit.}

\item{pmax}{Limit the maximum number of groups ever to be nonzero. For
example once a group enters the model, no matter how many times it exits or
re-enters model through the path, it will be counted only once.}

\item{eps}{Convergence termination tolerance. Defaults value is `1e-8`.}

\item{maxit}{Maximum number of outer-loop iterations allowed at fixed lambda
value. Default is `3e8`. If models do not converge, consider increasing
`maxit`.}

\item{interceptzero}{Double/Integer. The initial intercept into the optimization.}
}
\value{
An object with S3 class `"survival_sparsegl"`. Among the list components:
\item{call}{The call that produced this object.}
\item{b0}{Intercept sequence of length `length(lambda)`.}
\item{beta}{A `p` x `length(lambda)` sparse matrix of coefficients.}
\item{df}{The number of features with nonzero coefficients for each value of
    `lambda`.}
\item{dim}{Dimension of coefficient matrix.}
\item{lambda}{The actual sequence of `lambda` values used.}
\item{npasses}{Total number of iterations summed over all `lambda` values.}
\item{jerr}{Error flag, for warnings and errors, 0 if no error.}
\item{group}{A vector of consecutive integers describing the grouping of the
    coefficients.}
\item{nobs}{The number of observations used to estimate the model.}
}
\description{
R package 'Survivalml' is dedicated to run predictive high-dimensional mixed data logistic regression model which allows for censored data.

Fits regularization paths for sparse group-lasso penalized learning problems at a
sequence of regularization parameters `lambda`.
Note that the objective function for maximum likely hood function is
\deqn{log likelihood + \lambda penalty}
Users can also tweak the penalty by choosing a different penalty factor.
}
\examples{
n <- 2000
p=10
x1 <- rnorm(n)
x2 <- 0.2*x1 + rnorm(n)
x3= matrix(rnorm(n*p), nrow = n, ncol = p)  # Define parameters for generating y
intercept <- 5
coef_x1 <- 2
coef_x2 <- 0
coef_x3 <- rep(0,p)
#Generate y based on logistic function
logistic_function <- intercept + coef_x1 * x1 + coef_x2 * x2 + x3 \%*\% coef_x3
probabilities <- plogis(logistic_function)
y <- rbinom(n, 1, probabilities)
X <- data.frame(x1, x2, x3)
X = data.matrix(X)
index = seq(p+2)
weight = c( rep(0.2,100), rep(1,100), rep(1,n - 200))
fit = survival_sparsegl(X, y, group = index, nlambda = 1, lambda = c(0), weight = weight, intercept_zero = 0, standardize = TRUE)
fit
}
\seealso{
[cv.survival_sparsegl()] and [`predict()`][predict.survival_sparsegl()], and [`coef()`][coef.survival_sparsegl()]
  methods for `"survival_sparsegl"` objects.
}
